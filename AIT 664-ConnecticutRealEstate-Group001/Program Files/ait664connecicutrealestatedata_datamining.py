# -*- coding: utf-8 -*-
"""AIT664ConnecicutRealEstateData-DataMining.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h75Px4hyqUeL-eEk1nSAxdHo4CwhnDp_
"""

import geopandas as gpd
import pandas as pd

geojson_gdf = pd.read_csv("/content/Connecicut-EconomicImpactData-Locations.csv")

data = pd.DataFrame(geojson_gdf)

print(data.head())

data.info()

data.describe()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

def train_and_evaluate_model(X_train, y_train, X_test, y_test, model):
    # Fit the model
    model.fit(X_train, y_train)

    # Predict
    y_pred = model.predict(X_test)

    # Model Evaluation
    print("Model Evaluation:")
    print("MAE:", mean_absolute_error(y_test, y_pred))
    print("MSE:", mean_squared_error(y_test, y_pred))
    print("R-squared:", r2_score(y_test, y_pred))
    print()

    # Visualize actual vs predicted
    plt.figure(figsize=(10,6))
    plt.scatter(y_test, y_pred)
    plt.xlabel("Actual")
    plt.ylabel("Predicted")
    plt.title("Actual vs Predicted")
    plt.show()

def train_and_evaluate_models(data, target_variable):
    # Train/Test Split
    X = data[['BusinessEstablishment', 'EmploymentData', 'EmploymentWages', 'UnemploymentRates']]
    y = data[target_variable]
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model Selection
    models = {
        "Linear Regression": LinearRegression(),
        "Random Forest Regression": RandomForestRegressor(),
        "Gradient Boosting Regression": GradientBoostingRegressor()
    }

    for name, model in models.items():
        print(f"Model: {name}")
        train_and_evaluate_model(X_train, y_train, X_test, y_test, model)

grouped_data = data.groupby(['Town', 'List Year']).agg({
    'BusinessEstablishment': 'mean',
    'EmploymentData': 'mean',
    'EmploymentWages': 'mean',
    'UnemploymentRates': 'mean',
    'Houses Sold(Condo)': 'sum',
    'Condo_Average Assessed Value': 'mean',
    'Condo_Average Sale Amount': 'mean',
    'Condo_Average Sale Ratio': 'mean',
    'Houses Sold(Single)':'sum',
    'Single Family_Average Assessed Value':'mean',
    'Single Family_Average Sale Amount':'mean',
    'Single Family_Average Sale Ratio':'mean'
}).reset_index()

target_variables = [
    'Houses Sold(Condo)',
    'Condo_Average Assessed Value',
    'Condo_Average Sale Amount',
    'Condo_Average Sale Ratio'
]

target_variables_2 = [
    'Houses Sold(Single)',
    'Single Family_Average Assessed Value',
    'Single Family_Average Sale Amount',
    'Single Family_Average Sale Ratio'
]

for target_variable in target_variables:
    print(f"Target Variable: {target_variable}")
    train_and_evaluate_models(grouped_data, target_variable)

for target_variable in target_variables_2:
    print(f"Target Variable: {target_variable}")
    train_and_evaluate_models(grouped_data, target_variable)

from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

data.sort_values(by=['Town','List Year'], inplace=True)

def train_and_predict(df, target_variable):
    # Independent variables
    X = df[['BusinessEstablishment', 'EmploymentData', 'EmploymentWages', 'UnemploymentRates']]

    # Dependent variable
    y = df[target_variable]

    # Splitting the data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Model initialization and fitting
    model = RandomForestRegressor()
    model.fit(X_train, y_train)

    # Prediction
    y_pred = model.predict(X_test)

    # Model evaluation
    mae = mean_absolute_error(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print("Model Evaluation:")
    print(f"MAE: {mae}")
    print(f"MSE: {mse}")
    print(f"R-squared: {r2}")

    # Combine actual and predicted values into a DataFrame
    result_df = pd.DataFrame({
                          'Actual': y_test,
                          'Predicted': y_pred})
    return result_df

print("For Houses Sold(Condo):")
houses_sold_result = train_and_predict(data, 'Houses Sold(Condo)')

print("For Condo_Average Assessed Value:")
assessed_value_result = train_and_predict(data, 'Condo_Average Assessed Value')

print("For Condo_Average Sale Amount:")
sale_amount_result = train_and_predict(data, 'Condo_Average Sale Amount')

combined_results = pd.concat([houses_sold_result, assessed_value_result, sale_amount_result], axis=1)
combined_results

merged_data = data.merge(combined_results, on=['Town', 'List Year'], how='left')
merged_data
merged_data.to_csv('actual_vs_predictedv4.csv', index=True)

# Download the CSV file
from google.colab import files
files.download('actual_vs_predictedv4.csv')